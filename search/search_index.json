{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FPSim2's documentation","text":"<p>FPSim2 is a NumPy-centric Python/C++ package for running fast compound similarity searches. FPSim2 performs optimally with high search thresholds (&gt;=0.7). It is currently used in the ChEMBL and SureChEMBL interfaces.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Uses CPU POPCNT instruction for fast bit counting</li> <li>Implements bounds for sublinear speedups from 10.1021/ci600358f</li> <li>Features a compressed file format with optimized read speed based on PyTables and BLOSC2</li> <li>Provides fast multicore CPU and GPU similarity searches</li> <li>Supports in-memory and on-disk search modes</li> <li>Enables distance matrix calculation</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>Install and generate a FPSim2 fingerprint db file.</p> <ul> <li>Installation</li> <li>Create a fingerprint db file</li> <li>Sanitization</li> <li>Alternative SQLAlchemy backend</li> </ul>"},{"location":"#cpu-searches","title":"CPU searches","text":"<p>Learn how to run CPU based similarity searches:</p> <ul> <li>Run symmetric similarity searches</li> <li>Run Tversky asymmetric searches</li> <li>Run substructure screenouts</li> <li>Generate a symmetric distance matrix</li> </ul>"},{"location":"#gpu-searches","title":"GPU searches","text":"<p>Learn how to run GPU based similarity searches:</p> <ul> <li>Run GPU based Tanimoto similarity searches</li> </ul>"},{"location":"user_guide/contrib/","title":"Contributor modules","text":""},{"location":"user_guide/contrib/#isim-miranda-quintana-group-department-of-chemistry-university-of-florida","title":"iSIM (Miranda-Quintana Group, Department of Chemistry, University of Florida)","text":"<p>iSIM (R35GM150620) performs comparisons of multiple molecules at the same time and yields the same value as the average pairwise comparisons of molecules represented by binary fingerprints.</p> <pre><code>from FPSim2.contrib.isim.isim_comp import (\n    get_sim_dict,\n    calculate_medoid,\n    calculate_outlier,\n    calculate_comp_sim,\n)\nfrom FPSim2 import FPSim2Engine\n\nfp_filename = \"chembl_35_v0.6.0.h5\"\nfpe = FPSim2Engine(fp_filename)\n\n# get average similarity of the dataset\nsim_dict = get_sim_dict(fpe)\n\n# calculate medoid of the dataset\nmedoid = calculate_medoid(fpe)\n\n# calculate outlier of the dataset\noutlier = calculate_outlier(fpe)\n\n# calculate complementary similarity\ncomp_sim = calculate_comp_sim(fpe)\n</code></pre>"},{"location":"user_guide/create_db_file/","title":"Create a fingerprint database file","text":"<p>To create a fingerprint database file for running searches, use either:</p> <ul> <li>The <code>fpsim2-create-db</code> command line tool</li> <li>The <code>FPSim2.io.create_db_file</code> Python function</li> </ul> <p>Both methods are described below.</p> <p>Warning</p> <p>FPSim2 only supports integer molecule ids.</p> <p>The fingerprints are calculated with RDKit. Fingerprint types available are:</p> <ul> <li>MACCSKeys</li> <li>Morgan</li> <li>TopologicalTorsion</li> <li>AtomPair</li> <li>RDKit</li> <li>RDKitPattern</li> </ul>"},{"location":"user_guide/create_db_file/#using-the-command-line","title":"Using the command line","text":"<p>Run in parallel using .smi files as input. Example usage:</p> <pre><code>fpsim2-create-db smiles_file.smi fp_db.h5 --fp_type Morgan --fp_params '{\"radius\": 2, \"fpSize\": 256}' --processes 32\n</code></pre>"},{"location":"user_guide/create_db_file/#using-python","title":"Using Python","text":"<p>Note: When using the Python library, fingerprint calculation is single-threaded.</p> From a .sdf fileFrom a .smi fileFrom a Python listFrom any other iterable <pre><code>from FPSim2.io import create_db_file\n\ncreate_db_file(\n    mols_source='sdf_file.sdf',\n    filename='fp_db.h5',\n    mol_format=None, # set to None\n    fp_type='Morgan',\n    fp_params={'radius': 2, 'fpSize': 256},\n    mol_id_prop='mol_id'\n)\n</code></pre> <pre><code>from FPSim2.io import create_db_file\n\ncreate_db_file(\n    mols_source='smiles_file.smi',\n    filename='fp_db.h5',\n    mol_format=None, # set to None\n    fp_type='Morgan',\n    fp_params={'radius': 2, 'fpSize': 256}\n)\n</code></pre> <pre><code>from FPSim2.io import create_db_file\n\nmols = [['CC', 1], ['CCC', 2], ['CCCC', 3]]\ncreate_db_file(\n    mols_source=mols,\n    filename='fp_db.h5',\n    mol_format='smiles', # required\n    fp_type='Morgan',\n    fp_params={'radius': 2, 'fpSize': 256}\n)\n</code></pre> <p>SQLAlchemy CursorResult as an example</p> <pre><code>from FPSim2.io import create_db_file\nfrom sqlalchemy import create_engine, text\n\nengine = create_engine('sqlite:///test/test.db')\nwith engine.connect() as conn:\n    sql_query = text(\"select molfile, mol_id from structure\")\n    cursor = conn.execute(sql_query)\n\n    create_db_file(\n        mols_source=cursor,\n        filename='fp_db.h5',\n        mol_format='molfile', # required\n        fp_type='Morgan',\n        fp_params={'radius': 2, 'fpSize': 256}\n    )\n</code></pre>"},{"location":"user_guide/gpu/","title":"Running GPU Similarity Searches","text":"<p>Experimental CUDA Tanimoto similarity search is implemented via the CuPy library.</p> <p>Important</p> <p>Be sure to have CuPy properly installed before using this feature.</p> <p>Use the <code>similarity</code> function in the <code>FPSim2CudaEngine</code> class to run a Tanimoto similarity search:</p> <pre><code>from FPSim2 import FPSim2CudaEngine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpce = FPSim2CudaEngine(fp_filename)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpce.similarity(query, threshold=0.7)\n</code></pre>"},{"location":"user_guide/install/","title":"Installation","text":""},{"location":"user_guide/install/#pypi","title":"Pypi","text":"<p>Builds available for Linux (x86_64, arm64), MacOS (x86_64, arm64) and Windows (x86_64):</p> <pre><code>pip install fpsim2\n</code></pre>"},{"location":"user_guide/install/#from-source","title":"From source","text":"<p>For installation from source, Pybind11 is required as a build dependency.</p> <p>To potentially enhance CPU similarity searches performance on modern CPUs through compiler optimizations, set the environment variable FPSIM2_MARCH_NATIVE to 1 (note that this may not always improve performance depending on your system):</p> <pre><code>export FPSIM2_MARCH_NATIVE=1\npip install git+https://github.com/chembl/FPSim2.git\n</code></pre>"},{"location":"user_guide/sanitization/","title":"Sanitization","text":"<p>By default, FPSim2 uses RDKit's sanitization, which is the recommended approach. However, you have two alternatives:</p> <ol> <li>Use FPSim2's built-in partial sanitization</li> <li>Skip sanitization completely by providing your own RDKit molecule objects to the <code>create_db_file</code> function</li> </ol>"},{"location":"user_guide/sanitization/#partial-sanitization","title":"Partial Sanitization","text":"<p>Build-in FPSim2's partial sanitization applies the following rules:</p> <pre><code>def partial_sanitization(mol):\n    # https://rdkit.blogspot.com/2016/09/avoiding-unnecessary-work-and.html\n    mol.UpdatePropertyCache(strict=False)\n    Chem.FastFindRings(mol)\n    return mol\n</code></pre> <p>Use the <code>--no_full_sanitization</code> parameter in the <code>fpsim2-create-db</code> command line:</p> <pre><code>fpsim2-create-db smiles_file.smi fp_db.h5 --no_full_sanitization --fp_type Morgan --fp_params '{\"radius\": 2, \"fpSize\": 256}' --processes 32\n</code></pre> <p>Use <code>full_sanitization=False</code> when creating databases using <code>create_db_file</code> function</p> <pre><code>from FPSim2.io import create_db_file\n\nmols = [['CC', 1], ['CCC', 2], ['CCCC', 3]]\ncreate_db_file(\n    mols_source=mols,\n    filename='fp_db.h5',\n    mol_format='smiles', # required\n    fp_type='Morgan',\n    fp_params={'radius': 2, 'fpSize': 256},\n    full_sanitization=False\n)\n</code></pre> <p>When running similarity searches, partial sanitization of the query molecules can be also applied using the <code>full_sanitization=False</code> flag:</p> <pre><code>results = fpe.similarity(query, threshold=0.7, metric='tanimoto', full_sanitization=False, n_workers=1)\n</code></pre>"},{"location":"user_guide/sanitization/#custom-sanitization","title":"Custom Sanitization","text":"<p>For complete control over molecule sanitization, you can provide pre-sanitized RDKit molecule objects directly to <code>create_db_file</code>. These molecules will be used as-is without any additional sanitization during fingerprint generation.</p> <p>Example of custom sanitization:</p> <pre><code>from FPSim2.io import create_db_file\nfrom rdkit import Chem\n\nmols = [['CC', 1], ['CCC', 2], ['CCCC', 3]]\n\ndef parse_molecule(smiles):\n    mol = Chem.MolFromSmiles(smiles, sanitize=False)\n    # Apply custom sanitization steps\n    Chem.SanitizeMol(mol, sanitizeOps=Chem.SANITIZE_ALL^Chem.SANITIZE_CLEANUP^Chem.SANITIZE_CLEANUPCHIRALITY)\n    return mol\n\n# Create list of [mol, id] pairs\nmols = [[parse_molecule(smi), mol_id] for smi, mol_id in mols]\n\ncreate_db_file(\n    mols_source=mols,\n    filename='fp_db.h5',\n    mol_format='rdkit',  # Important: specify rdkit format\n    fp_type='Morgan',\n    fp_params={'radius': 2, 'fpSize': 256}\n)\n</code></pre> <p>Run a search with the custom sanitization:</p> <pre><code>def parse_molecule(smiles):\n    mol = Chem.MolFromSmiles(smiles, sanitize=False)\n    # Apply custom sanitization steps\n    Chem.SanitizeMol(mol, sanitizeOps=Chem.SANITIZE_ALL^Chem.SANITIZE_CLEANUP^Chem.SANITIZE_CLEANUPCHIRALITY)\n    return mol\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.similarity(parse_molecule(query), threshold=0.7, metric='tanimoto', full_sanitization=False, n_workers=1)\n</code></pre>"},{"location":"user_guide/sim_matrix/","title":"Computing a Symmetric Distance Matrix","text":"<p>Use the <code>FPSim2Engine.symmetric_distance_matrix</code> function to create a SciPy CSR sparse distance matrix from the current dataset:</p> <p>Similarity Metrics</p> <p>Possible metrics that can be used are (<code>tanimoto</code> is default):</p> <ul> <li><code>tanimoto</code> (Jaccard): Measures the ratio of intersection to union. \\(T(A,B) = \\frac{|A \\cap B|}{|A \\cup B|} = \\frac{c}{a + b - c}\\)</li> <li><code>dice</code> (Dice-S\u00f8rensen): Emphasizes the intersection more than Tanimoto. \\(D(A,B) = \\frac{2|A \\cap B|}{|A| + |B|} = \\frac{2c}{a + b}\\)</li> <li><code>cosine</code> (Otsuka\u2013Ochiai): Also focuses on shared features but is less affected by the total number of features. \\(C(A,B) = \\frac{|A \\cap B|}{\\sqrt{|A| \\cdot |B|}} = \\frac{c}{\\sqrt{a \\cdot b}}\\)</li> </ul> <p>Where:</p> <ul> <li>\\(a\\) is the number of bits set to 1 in fingerprint A</li> <li>\\(b\\) is the number of bits set to 1 in fingerprint B</li> <li>\\(c\\) is the number of bits set to 1 in both fingerprints</li> </ul> <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename)\ncsr_matrix = fpe.symmetric_distance_matrix(threshold=0.7, metric=\"tanimoto\", n_workers=4)\n</code></pre> <p>Note</p> <p>Code above generating the symmetric matrix of ChEMBL 27 (1941405 compounds) took 3.5h, using 4 cores, running in a 2019 core i9 laptop. 12.5h in a single core.</p> <p>The order of the compounds is the same one than in the fps file (the compounds get sorted by number of fingerprint features). To get the fps ids:</p> <pre><code>ids = fpe.fps[:, 0]\n</code></pre> <p>The CSR distance matrix can be used as an input for some scikit-learn algorithms supporting \"precomputed\" distance metrics. Some others may need a similarity matrix. A CSR distance matrix can be easily converted into a similarity matrix:</p> <pre><code>csr_matrix.data = 1 - csr_matrix.data\n# 0's in the diagonal of the matrix are implicit so they are not affected by the instruction above\ncsr_matrix.setdiag(1)\n</code></pre> <p>Finally, some algorithms (e.g. MDS) require a dense matrix. Conversion to a dense matrix can be easily done but bear in mind that the number of elements in the dense matrix will be the square of the number of your compounds and this may not fit in your memory:</p> <pre><code># classic MDS doesn't work with missing values, so it's better to only use it with threshold 0.0\n# in case you still want to run MDS on missing values matrices\n# this example uses the SMACOF algorithm which is known for being able to deal with missing data. \n# Use it at your own risk!\n\nfrom sklearn.manifold import MDS\n\ndense_matrix = csr_matrix.todense()\n\n# with metric=False it uses the SMACOF algorithm\nmds = MDS(dissimilarity=\"precomputed\", metric=False)\npos = mds.fit_transform(dense_matrix)\n</code></pre>"},{"location":"user_guide/similarity/","title":"Symmetric Similarity Searches","text":"<p>Run a similarity search to find compounds that are structurally similar to a query molecule.</p> <p>Similarity Metrics</p> <p>Possible metrics that can be used are (<code>tanimoto</code> is default):</p> <ul> <li><code>tanimoto</code> (Jaccard): Measures the ratio of intersection to union. \\(T(A,B) = \\frac{|A \\cap B|}{|A \\cup B|} = \\frac{c}{a + b - c}\\)</li> <li><code>dice</code> (Dice-S\u00f8rensen): Emphasizes the intersection more than Tanimoto. \\(D(A,B) = \\frac{2|A \\cap B|}{|A| + |B|} = \\frac{2c}{a + b}\\)</li> <li><code>cosine</code> (Otsuka\u2013Ochiai): Also focuses on shared features but is less affected by the total number of features. \\(C(A,B) = \\frac{|A \\cap B|}{\\sqrt{|A| \\cdot |B|}} = \\frac{c}{\\sqrt{a \\cdot b}}\\)</li> </ul> <p>Where:</p> <ul> <li>\\(a\\) is the number of bits set to 1 in fingerprint A</li> <li>\\(b\\) is the number of bits set to 1 in fingerprint B</li> <li>\\(c\\) is the number of bits set to 1 in both fingerprints</li> </ul> In memoryOn disk <p>Use the <code>FPSim2Engine.similarity</code> function to run symmetric similarity searches.</p> <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.similarity(query, threshold=0.7, metric='tanimoto', n_workers=1)\n</code></pre> <p>Use the <code>FPSim2Engine.on_disk_similarity</code> function to run similarity searches on disk. This method is much slower but suitable when working with databases larger than available RAM. To use ONLY if the dataset doesn't fit in memory.</p> <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename, in_memory_fps=False)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.on_disk_similarity(query, threshold=0.7, metric='tanimoto')\n</code></pre> <p>Parallel Processing</p> <p>The <code>n_workers</code> parameter can be used to split a single query into multiple threads to speed up the search. This is especially useful when searching large datasets.</p>"},{"location":"user_guide/similarity/#top-k-searches","title":"Top K Searches","text":"In memoryOn disk <p>Retrieve the top K most similar hits using the <code>FPSim2Engine.top_k</code> function.</p> <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.top_k(query, k=100, threshold=0.7, metric='tanimoto', n_workers=1)\n</code></pre> <p>Use the <code>FPSim2Engine.on_disk_top_k</code> function to run top-K searches on disk. This method is much slower but suitable when working with databases larger than available RAM. To use ONLY if the dataset doesn't fit in memory.</p> <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename, in_memory_fps=False)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.on_disk_top_k(query, k=100, threshold=0.7, metric='tanimoto')\n</code></pre>"},{"location":"user_guide/sql_backend/","title":"SQLAlchemy backend","text":"<p>PyTables h5 file is FPSim2's primary backend for storing fingerprints, but an SQL backend is available for MySQL, PostgreSQL, or Oracle databases.</p> <p>This alternative backend is particularly useful when you need to:</p> <ul> <li>Build your database incrementally</li> <li>Integrate with existing database infrastructure</li> <li>Prefer database management over file-based storage in your deployments</li> </ul> <p>Warning</p> <p>The SQLAlchemy backend's fingerprint loading time is noticeably slower than PyTables h5 files. Once loaded, search performance is identical. For optimal loading performance with large-scale datasets, we recommend using the PyTables default backend.</p>"},{"location":"user_guide/sql_backend/#create-database-table","title":"Create database table","text":"<p>Using a PostgreSQL for the example</p> <pre><code>from FPSim2.io import create_db_table\n\nfp_type = \"Morgan\"\nfp_params = {\"radius\": 2, \"fpSize\": 256}\ndb_url = \"postgresql://user:password@hostname:5432/fpsim2\"\ntable_name = \"fpsim2_fp_table\"\nmol_format = \"smiles\"\n\nsmiles_list = [\n    [\"Cc1cc(-n2ncc(=O)[nH]c2=O)ccc1C(=O)c1ccccc1Cl\", 1],\n    [\"Cc1cc(-n2ncc(=O)[nH]c2=O)ccc1C(=O)c1ccc(C#N)cc1\", 2],\n    [\"Cc1cc(-n2ncc(=O)[nH]c2=O)cc(C)c1C(O)c1ccc(Cl)cc1\", 3],\n    [\"Cc1ccc(C(=O)c2ccc(-n3ncc(=O)[nH]c3=O)cc2)cc1\", 4],\n    [\"Cc1cc(-n2ncc(=O)[nH]c2=O)ccc1C(=O)c1ccc(Cl)cc1\", 5],\n]\n\ncreate_db_table(smiles_list, db_url, table_name, mol_format, fp_type, fp_params)\n</code></pre>"},{"location":"user_guide/sql_backend/#incremental-load","title":"Incremental load","text":"<p>You can append molecules to an existing table using the <code>create_db_table</code> function. For databases where structures are stored in the same SQL instance, you can populate the table using a SQLAlchemy CursorResult:</p> <pre><code>from sqlalchemy import create_engine, text\nfrom FPSim2.io import create_db_table\n\nfp_type = \"Morgan\"\nfp_params = {\"radius\": 2, \"fpSize\": 256}\ndb_url = \"postgresql://user:password@hostname:5432/fpsim2\"\ntable_name = \"fpsim2_fp_table\"\nmol_format = \"smiles\"\n\nsql_query = text(f\"\"\"\n    SELECT\n        smiles,\n        mol_id\n    FROM\n        structure\n    WHERE\n        mol_id &gt; COALESCE((\n            SELECT\n                MAX(mol_id)\n            FROM\n                {table_name}\n        ), 0)\n    ORDER BY\n        mol_id\n\"\"\")\n\nengine = create_engine(db_url)\nwith engine.connect() as conn:\n    cursor = conn.execute(sql_query)\n    create_db_table(cursor, db_url, table_name, mol_format, fp_type, fp_params)\n</code></pre>"},{"location":"user_guide/sql_backend/#loading-the-fingerprints","title":"Loading the fingerprints:","text":"<p>Once the fingerprints are stored in the database, load them into FPSim2Engine using the same database url and table name:</p> <pre><code>from FPSim2 import FPSim2Engine\n\ndb_url = \"postgresql://user:password@hostname:5432/fpsim2\"\ntable_name = \"fpsim2_fp_table\"\n\nfpe = FPSim2Engine(\n    conn_url=db_url, table_name=table_name, storage_backend=\"sqla\"\n)\n</code></pre>"},{"location":"user_guide/sql_backend/#running-a-search","title":"Running a search","text":"<p>Running similarity searches with the SQLAlchemy backend is identical to using the PyTables backend:</p> <pre><code>query = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.similarity(query, threshold=0.7, metric='tanimoto', n_workers=1)\n</code></pre>"},{"location":"user_guide/sql_backend/#saving-the-table-to-a-pytables-h5-file","title":"Saving the table to a PyTables h5 file","text":"<p>You can export the fingerprints stored in SQL to the PyTables h5 file format, which is useful for sharing or distributing the data you have in SQL:</p> <pre><code>fpe.save_h5(\"my_fps.h5\")\n</code></pre>"},{"location":"user_guide/subs_screenout/","title":"Substructure Screenouts","text":"<p>Run an optimised Tversky (a=1, b=0, threshold=1.0) substructure screenout. Note that this is not a full substructure (i.e., with subgraph isomorphism) search.</p> <p>Tip</p> <p>It's recommended to use RDKitPattern fingerprint type with this kind of searches.</p> In memoryOn disk <p>Use the <code>FPSim2Engine.substructure</code> function to run a substructure screenout. <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.substructure(query, n_workers=1)\n</code></pre></p> <p>Use the <code>FPSim2Engine.on_disk_substructure</code> function to run substructure screenouts on disk. This method is much slower but suitable when working with databases larger than available RAM. To use ONLY if the dataset doesn't fit in memory.</p> <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename, in_memory_fps=False)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.on_disk_substructure(query, n_workers=1)\n</code></pre> <p>Parallel Processing</p> <p>The <code>n_workers</code> parameter can be used to split a single query into multiple threads to speed up the search. This is especially useful when searching large datasets.</p>"},{"location":"user_guide/tversky/","title":"Tversky Searches","text":"<p>Run a Tversky search. The Tversky similarity coefficient is a generalization of the Tanimoto coefficient that allows asymmetric weighting between query and reference fingerprints.</p> <p>Using <code>a</code> and <code>b</code> Parameters</p> <p>The <code>a</code> and <code>b</code> parameters in the <code>tversky</code> function control the weighting of the query and reference fingerprints, respectively. Adjusting these values allows you to fine-tune the similarity measure to emphasize different aspects of the fingerprints. For example, setting <code>a</code> to a higher value than <code>b</code> will give more weight to the query fingerprint.</p> In memoryOn disk <p>Use the <code>FPSim2Engine.tversky</code> function to run a Tversky search. <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.tversky(query, threshold=0.7, a=0.7, b=0.3, n_workers=1)\n</code></pre></p> <p>Use the <code>FPSim2Engine.on_disk_tversky</code> function to run Tversky searches on disk. This method is much slower but suitable when working with databases larger than available RAM. To use ONLY if the dataset doesn't fit in memory.</p> <pre><code>from FPSim2 import FPSim2Engine\n\nfp_filename = 'chembl_35_v0.6.0.h5'\nfpe = FPSim2Engine(fp_filename, in_memory_fps=False)\n\nquery = 'CC(=O)Oc1ccccc1C(=O)O'\nresults = fpe.on_disk_tversky(query, threshold=0.7, a=0.7, b=0.3)\n</code></pre> <p>Parallel Processing</p> <p>The <code>n_workers</code> parameter can be used to split a single query into multiple threads to speed up the search. This is especially useful when searching large datasets.</p>"}]}